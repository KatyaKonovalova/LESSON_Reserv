# int, float, str, tuple, frozen_set, None - неизменяемые
# list, dict, set - изменяемые

# O(1) - не зависит от размеров структуры, О от единицы, или О от константы
# O(n) - например, цикл for
# O(n^2) - например цикл for + вложенный в него for

# Если есть два цикла, но не вложенных, а отдельных, то
# O(n) + O(n) = O(n + n) = O(2n) = O(n)

# Если был цикл сложности O(n^2), затем цикл сложности O(n), то
# O(n^2) + O(n) = O(n^2 + n) = O(n^2)

# Пример
a = 5
# Сложность O(n), элементы списка могут быть любыми, в том числе не хэшируемыми, т.е. изменяемыми
print(a in [1, 2, 3, 4, 5])
# Сложность O(1), элементы множества хэшируются, чтобы обеспечить их уникальность
print(a in {1, 2, 3, 4, 5})

# Скорость получения элемента по ключу в словаре O(1), потому что они [ключи] хэшируются, обеспечивая уникальность

print({'a': [1, 2, 3]})  # 'a' - хэшируемый объект, поэтому может быть ключом, а значение может быть каким угодно


# Задача
a = [1, 2, 3]
b = [i for i in range(1, 10)]
for elem in b:
    if elem in a:  # O(n)
        print(elem)
# Сложность алгоритма: O(n) + O(n) * O(n) = O(n) + O(n^2) = O(n^2)

# Как улучшить?
a = {1, 2, 3}
b = [i for i in range(1, 10)]
for elem in b:
    if elem in a:  # O(1)
        print(elem)
# Сложность алгоритма: O(n) + O(n) * O(1) = O(n) + O(n) = O(2n) = O(n)

# 1 in {1: ..., 2: ..., ...: ...} - сложность O(1), т.к. поиск по ключам, которые хэшируются
# 1 in [1, 2, 3, ...] - сложность O(n), т.к. элементы списка могут быть любыми
